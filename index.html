<!doctype html>
<html lang="sv">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Suicidpreventiva dagen – En plats för ljus och minne</title>
    <link rel="stylesheet" href="index.css" />
  <script type="importmap">
{
  "imports": {
    "@vercel/kv": "https://aistudiocdn.com/@vercel/kv@^3.0.0",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.17.0"
  }
}
</script>
</head>
  <body>
    <div id="memorial-scene">
      <div id="candle-container"></div>
    </div>

    <div id="message-display" class="hidden">
      <p id="message-text"></p>
      <button id="close-message-btn">&times;</button>
    </div>

    <div id="ui-container">
      <header>
        <h1>Tänd ett ljus den 10 september</h1>
        <p>
          På Suicidpreventiva dagen tänder vi ljus för att minnas de vi förlorat, stötta de som kämpar och sprida hopp.
        </p>
      </header>
      <div class="counter">
        <span id="candle-count">0</span> ljus har tänts för att minnas.
      </div>

      <div id="interaction-area" class="state-initial">
        <button id="light-candle-btn">Tänd ett ljus</button>
        <div id="message-input-area">
          <textarea
            id="message-input"
            placeholder="Lämna ett varmt meddelande (max 150 tecken)..."
            maxlength="150"
            aria-label="Meddelande"
          ></textarea>
          <button id="submit-message-btn">Skicka</button>
          <p id="error-message" style="display: none; color: #ff8a80; margin-top: 10px;"></p>
        </div>
        <p id="thank-you-message">
          Tack för att du visade ditt stöd.
        </p>
      </div>
    </div>

    <script type="module">
      /**
       * @license
       * SPDX-License-Identifier: Apache-2.0
       */

      document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const memorialScene = document.getElementById('memorial-scene');
        const candleContainer = document.getElementById('candle-container');
        const lightCandleBtn = document.getElementById('light-candle-btn');
        const candleCountSpan = document.getElementById('candle-count');
        const interactionArea = document.getElementById('interaction-area');
        const messageInput = document.getElementById('message-input');
        const submitMessageBtn = document.getElementById('submit-message-btn');
        const errorMessage = document.getElementById('error-message');
        const messageDisplay = document.getElementById('message-display');
        const messageText = document.getElementById('message-text');
        const closeMessageBtn = document.getElementById('close-message-btn');

        // --- State and Constants ---
        const ZOOM_FACTOR_PER_CANDLE = 0.002;
        const MAX_ZOOM_OUT = 0.4;
        let candleCount = 0;
        let initialCandleCount = 0;

        /**
         * Creates and adds a single candle element to the scene.
         * @param {string | null} message - The message to attach to the candle.
         * @param {boolean} [isInitial=false] - If true, the candle fades in immediately.
         */
        function addCandleToScene(message, isInitial = false) {
          if (!candleContainer) return;

          const candle = document.createElement('div');
          candle.className = 'candle';

          if (message) {
            candle.classList.add('has-message');
            candle.dataset.message = message;
          }

          const x = Math.random() * 95 + 2.5;
          const y = Math.random() * 95 + 2.5; // Use more vertical space
          candle.style.left = `${x}%`;
          candle.style.top = `${y}%`;

          const size = Math.random() * 10 + 5;
          candle.style.width = `${size}px`;
          candle.style.height = `${size}px`;

          const flickerDuration = (Math.random() * 2 + 3).toFixed(2); // Random duration between 3s and 5s

          if (isInitial) {
            // Initial candles fade in over 3s. Start flickering after that + a random delay.
            const flickerDelay = (3 + Math.random() * 2).toFixed(2);
            candle.style.animation = `fadeIn 3s ease-out forwards, candleGlow ${flickerDuration}s ease-in-out ${flickerDelay}s infinite alternate`;
          } else {
            // User-lit candles fade in over 2s with a 0.5s delay. Flicker starts right after.
            const userFadeInDuration = 2;
            const userFadeInDelay = 0.5;
            const flickerStartTime = userFadeInDuration + userFadeInDelay;
            candle.style.animation = `fadeIn ${userFadeInDuration}s ease-out ${userFadeInDelay}s forwards, candleGlow ${flickerDuration}s ease-in-out ${flickerStartTime}s infinite alternate`;
          }

          candleContainer.appendChild(candle);
          candleCount++;
        }

        /**
         * Updates the UI counter and applies the zoom-out effect.
         */
        function updateView() {
          if (candleCountSpan) {
            candleCountSpan.textContent = candleCount.toString();
          }

          if (candleContainer) {
            const candlesAddedBeyondInitial = Math.max(0, candleCount - initialCandleCount);
            const scale = 1 - (candlesAddedBeyondInitial * ZOOM_FACTOR_PER_CANDLE);
            const finalScale = Math.max(MAX_ZOOM_OUT, scale);
            candleContainer.style.transform = `scale(${finalScale})`;
          }
        }

        /**
         * Sets the state of the interaction area, controlling which element is visible.
         * @param {'initial' | 'input' | 'thanks'} state - The state to set.
         */
        function setInteractionState(state) {
          if (!interactionArea) return;
          interactionArea.className = `state-${state}`;
        }

        /**
         * Shows the message input form.
         */
        function showInputForm() {
          setInteractionState('input');
          if (messageInput) {
            messageInput.value = ''; // Clear previous message
          }
          if (errorMessage) {
            errorMessage.style.display = 'none'; // Also reset error message
          }
          if (submitMessageBtn) {
            submitMessageBtn.disabled = false;
            submitMessageBtn.textContent = 'Skicka';
          }
        }

        /**
         * Uses a backend endpoint to moderate the user's message.
         * @param {string} message - The message to moderate.
         * @returns {Promise<'SAFE' | 'UNSAFE'>}
         */
        async function moderateMessage(message) {
          try {
            const response = await fetch('/api/moderate', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ message }),
            });

            if (!response.ok) {
              console.error('Moderation API request failed');
              return 'UNSAFE';
            }

            const data = await response.json();
            return data.result === 'SAFE' ? 'SAFE' : 'UNSAFE';
          } catch (error) {
            console.error('Error calling moderation API:', error);
            return 'UNSAFE'; // Fail closed on network errors etc.
          }
        }

        /**
         * Sends the new message to the backend to be saved.
         * @param {string} newMessage The new message to add.
         * @returns {Promise<boolean>}
         */
        async function saveMessageToBackend(newMessage) {
          try {
            const response = await fetch('/api/add-candle', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ message: newMessage }),
            });
            return response.ok;
          } catch (error) {
            console.error('Could not save message to backend:', error);
            return false;
          }
        }

        /**
         * Handles the submission of a message.
         */
        async function handleMessageSubmit() {
          if (!messageInput || !submitMessageBtn || !errorMessage) {
            return;
          }
          try {
            const message = messageInput.value.trim();
            if (message.length === 0) return;

            submitMessageBtn.disabled = true;
            submitMessageBtn.textContent = 'Granskar...';
            errorMessage.style.display = 'none';

            const moderationResult = await moderateMessage(message);

            if (moderationResult === 'SAFE') {
              const success = await saveMessageToBackend(message);
              if (success) {
                addCandleToScene(message, false);
                updateView();
                setInteractionState('thanks');
                // Reset UI to initial state after a delay to allow lighting more candles
                setTimeout(() => {
                  setInteractionState('initial');
                }, 3000);
              } else {
                errorMessage.textContent = 'Kunde inte spara meddelandet. Försök igen.';
                errorMessage.style.display = 'block';
                submitMessageBtn.disabled = false;
                submitMessageBtn.textContent = 'Skicka';
              }
            } else {
              errorMessage.textContent = 'Meddelandet godkändes inte. Vänligen justera och försök igen.';
              errorMessage.style.display = 'block';
              submitMessageBtn.disabled = false;
              submitMessageBtn.textContent = 'Skicka';
            }
          } catch (error) {
            console.error('A critical error occurred during message submission:', error);
            errorMessage.textContent = 'Ett oväntat fel inträffade. Vänligen försök igen senare.';
            errorMessage.style.display = 'block';
            if (submitMessageBtn) {
              submitMessageBtn.disabled = false;
              submitMessageBtn.textContent = 'Skicka';
            }
          }
        }

        /**
         * Shows the message display popup.
         * @param {string} text - The message to show.
         * @param {HTMLElement} targetElement - The element to position the popup near.
         */
        function showMessage(text, targetElement) {
          if (!messageDisplay || !messageText) return;

          messageText.textContent = text;
          messageDisplay.classList.remove('hidden');
          messageDisplay.classList.add('visible');

          const targetRect = targetElement.getBoundingClientRect();
          const popupRect = messageDisplay.getBoundingClientRect();

          let top = targetRect.top - popupRect.height - 10;
          let left = targetRect.left + targetRect.width / 2 - popupRect.width / 2;

          if (top < 10) top = targetRect.bottom + 10;
          if (left < 10) left = 10;
          if (left + popupRect.width > window.innerWidth - 10) {
            left = window.innerWidth - popupRect.width - 10;
          }

          messageDisplay.style.top = `${top}px`;
          messageDisplay.style.left = `${left}px`;
        }

        /**
         * Hides the message display popup.
         */
        function hideMessage() {
          if (!messageDisplay) return;
          messageDisplay.classList.remove('visible');
          messageDisplay.classList.add('hidden');
        }

        /**
         * Creates a shooting star element and animates it.
         */
        function createShootingStar() {
          if (!memorialScene) return;
          const wrapper = document.createElement('div');
          wrapper.className = 'shooting-star-wrapper';

          const star = document.createElement('div');
          star.className = 'shooting-star';

          const top = Math.random() * 60;
          wrapper.style.top = `${top}%`;
          wrapper.style.left = `-200px`;

          const angle = Math.random() * 20 - 10;
          const duration = Math.random() * 3 + 4;

          wrapper.style.transform = `rotate(${angle}deg)`;
          star.style.animationDuration = `${duration}s`;

          wrapper.appendChild(star);
          memorialScene.appendChild(wrapper);

          setTimeout(() => {
            wrapper.remove();
          }, duration * 1000);
        }

        /**
         * Schedules the next shooting star to appear after a random delay.
         */
        function scheduleNextShootingStar() {
          const delay = Math.random() * 15000 + 10000; // 10-25 seconds
          setTimeout(() => {
            createShootingStar();
            scheduleNextShootingStar();
          }, delay);
        }

        /**
         * Initializes the memorial scene.
         */
        async function initialize() {
          try {
            const response = await fetch('/api/get-candles');
            if (response.ok) {
              const candles = await response.json();
              initialCandleCount = candles.length;
              candles.forEach((candle) => addCandleToScene(candle.message, true));
              updateView();
            } else {
              console.error('Could not load initial candles, using fallback.');
              addCandleToScene('Du är inte ensam.', true);
              initialCandleCount = 1;
              updateView();
            }
          } catch (error) {
            console.error('Error fetching initial candles:', error);
            addCandleToScene('Du är inte ensam.', true);
            initialCandleCount = 1;
            updateView();
          }
        }

        // --- Event Listeners ---
        lightCandleBtn?.addEventListener('click', showInputForm);
        submitMessageBtn?.addEventListener('click', handleMessageSubmit);
        closeMessageBtn?.addEventListener('click', hideMessage);

        memorialScene?.addEventListener('click', (event) => {
          const target = event.target;
          if (target instanceof HTMLElement && target.classList.contains('has-message') && target.dataset.message) {
            showMessage(target.dataset.message, target);
          }
        });

        // --- Start the application ---
        initialize();
        scheduleNextShootingStar();
      });
    </script>
  </body>
</html>
