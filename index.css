/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */

import { GoogleGenAI, Type } from "@google/genai";

// --- DOM Elements ---
const memorialScene = document.getElementById('memorial-scene') as HTMLDivElement;
const candleContainer = document.getElementById('candle-container') as HTMLDivElement;
const lightCandleBtn = document.getElementById('light-candle-btn') as HTMLButtonElement;
const candleCountSpan = document.getElementById('candle-count') as HTMLSpanElement;
const thankYouMessage = document.getElementById('thank-you-message') as HTMLParagraphElement;
const messageDisplay = document.getElementById('message-display') as HTMLDivElement;
const messageText = document.getElementById('message-text') as HTMLParagraphElement;
const closeMessageBtn = document.getElementById('close-message-btn') as HTMLButtonElement;
const messageForm = document.getElementById('message-form') as HTMLFormElement;
const messageInput = document.getElementById('message-input') as HTMLTextAreaElement;
const errorMessage = document.getElementById('error-message') as HTMLParagraphElement;


// --- State and Constants ---
const LOCAL_STORAGE_KEY = 'suicidePreventionMemorial';
const INITIAL_CANDLE_COUNT = 75; 
const ZOOM_FACTOR_PER_CANDLE = 0.002;
const MAX_ZOOM_OUT = 0.4;
let candleCount = 0;

const predefinedMessages = [
  "Du är inte ensam.",
  "Det finns hopp, även när det känns som mörkast.",
  "En dag i taget. Du klarar det här.",
  "Vila. Du behöver inte lösa allt på en gång.",
  "Din existens gör världen ljusare.",
  "Till minne av en älskad vän.",
  "Vi tänker på dig.",
  "Tillsammans är vi starka.",
  "Det är okej att inte vara okej.",
  "Var snäll mot dig själv.",
  "För de vi saknar, i evigt minne."
];

// --- Gemini AI Setup ---
let ai: GoogleGenAI | null = null;
try {
  ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
} catch (error) {
  console.error("Failed to initialize GoogleGenAI:", error);
  // Hide form if AI cannot be initialized
  if (messageForm) {
    messageForm.style.display = 'none';
    showError("Kunde inte ansluta till tjänsten. Försök igen senare.");
  }
}

/**
 * Uses Gemini to check if a message is appropriate for the memorial.
 * @param message The user's message.
 * @returns An object with `isAppropriate` (boolean) and `reason` (string).
 */
async function checkMessageAppropriateness(message: string): Promise<{isAppropriate: boolean, reason: string}> {
  if (!ai) {
    return { isAppropriate: false, reason: "AI-tjänsten är inte tillgänglig." };
  }
  
  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: `Analysera följande meddelande för en digital minnesplats för suicidprevention. Är det lämpligt? Meddelandet ska vara stödjande, hoppfullt eller ett respektfullt minne. Det får absolut inte innehålla skadligt språk, uppmana till självskada, vara hatiskt eller innehålla personlig information. Meddelande: "${message}"`,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            isAppropriate: {
              type: Type.BOOLEAN,
              description: 'Är meddelandet lämpligt enligt riktlinjerna?',
            },
            reason: {
              type: Type.STRING,
              description: 'En kort anledning om varför det inte är lämpligt.',
            },
          },
          required: ["isAppropriate", "reason"],
        },
      },
    });

    const jsonText = response.text.trim();
    const result = JSON.parse(jsonText);
    return {
        isAppropriate: result.isAppropriate,
        reason: result.reason || 'Okänt fel.'
    };
  } catch (error) {
    console.error('Error moderating message:', error);
    return { isAppropriate: false, reason: "Kunde inte verifiera meddelandet. Försök igen." };
  }
}

/**
 * Displays an error message to the user.
 * @param text The error text to display.
 */
function showError(text: string) {
    if(!errorMessage) return;
    errorMessage.textContent = text;
    errorMessage.classList.add('error-visible');
    errorMessage.classList.remove('error-hidden');
}

/**
 * Hides the error message.
 */
function hideError() {
    if(!errorMessage) return;
    errorMessage.classList.add('error-hidden');
    errorMessage.classList.remove('error-visible');
}


/**
 * Creates and adds a single candle element to the scene.
 * @param message - The message to attach to the candle.
 * @param isInitial - If true, the candle fades in immediately.
 * @returns The newly created candle element.
 */
function addCandleToScene(message: string, isInitial = false): HTMLDivElement {
  if (!candleContainer) throw new Error("Candle container not found");

  const candle = document.createElement('div');
  candle.className = 'candle has-message';
  candle.dataset.message = message;
  
  const x = Math.random() * 95 + 2.5;
  const y = Math.random() * 95 + 2.5;
  candle.style.left = `${x}%`;
  candle.style.top = `${y}%`;
  
  const size = Math.random() * 10 + 5;
  candle.style.width = `${size}px`;
  candle.style.height = `${size}px`;
  
  const flickerDuration = (Math.random() * 2 + 3).toFixed(2); 

  if (isInitial) {
    const flickerDelay = (3 + Math.random() * 2).toFixed(2);
    candle.style.animation = `fadeIn 3s ease-out forwards, candleGlow ${flickerDuration}s ease-in-out ${flickerDelay}s infinite alternate`;
  } else {
    const userFadeInDuration = 2;
    const userFadeInDelay = 0.5;
    const flickerStartTime = userFadeInDuration + userFadeInDelay;
    candle.style.animation = `fadeIn ${userFadeInDuration}s ease-out ${userFadeInDelay}s forwards, candleGlow ${flickerDuration}s ease-in-out ${flickerStartTime}s infinite alternate`;
  }

  candleContainer.appendChild(candle);
  candleCount++;
  return candle;
}

/**
 * Displays a sparkle animation at a specific viewport location.
 * @param x - The horizontal coordinate.
 * @param y - The vertical coordinate.
 */
function showSparkleAt(x: number, y: number): void {
  const sparkle = document.createElement('div');
  sparkle.className = 'sparkle';
  sparkle.style.left = `${x}px`;
  sparkle.style.top = `${y}px`;
  document.body.appendChild(sparkle);
  sparkle.addEventListener('animationend', () => {
      sparkle.remove();
  });
}

/**
 * Updates the UI counter and applies the zoom-out effect.
 */
function updateView(): void {
  if (candleCountSpan) {
    candleCountSpan.textContent = candleCount.toString();
  }

  if (candleContainer) {
    const candlesAddedByUser = Math.max(0, candleCount - INITIAL_CANDLE_COUNT);
    const scale = 1 - (candlesAddedByUser * ZOOM_FACTOR_PER_CANDLE);
    const finalScale = Math.max(MAX_ZOOM_OUT, scale);
    candleContainer.style.transform = `scale(${finalScale})`;
  }
}

/**
 * Checks if the user has already lit a candle in a previous session.
 */
function checkSessionState(): void {
  let sessionData = null;
  try {
    const storedData = localStorage.getItem(LOCAL_STORAGE_KEY);
    if (storedData) {
      sessionData = JSON.parse(storedData);
    }
  } catch (e) {
    console.error('Could not read from localStorage', e);
  }

  if (sessionData?.hasLit) {
    if (messageForm && thankYouMessage) {
      messageForm.style.display = 'none';
      thankYouMessage.style.display = 'block';
    }
    // Add their candle from last time, but without making it clickable for them again.
    if (sessionData.message) {
        addCandleToScene(sessionData.message, true);
    }
  }
}

/**
 * Shows a message in the display modal.
 * @param candle - The candle element that was clicked.
 */
function showMessage(candle: HTMLElement): void {
  const message = candle.dataset.message;
  if (!message || !messageDisplay || !messageText) return;

  messageText.textContent = `"${message}"`;
  
  const candleRect = candle.getBoundingClientRect();
  const viewX = candleRect.left + (candleRect.width / 2);
  const viewY = candleRect.top + (candleRect.height / 2);

  messageDisplay.style.left = `${viewX}px`;
  messageDisplay.style.top = `${viewY}px`;
  messageDisplay.style.transform = 'translate(-50%, -120%)';
  messageDisplay.classList.remove('hidden');
  messageDisplay.classList.add('visible');
}

/**
 * Hides the message display modal.
 */
function hideMessage(): void {
  if (!messageDisplay) return;
  messageDisplay.classList.remove('visible');
  setTimeout(() => {
    if (!messageDisplay.classList.contains('visible')) {
        messageDisplay.classList.add('hidden');
    }
  }, 300);
}

/**
 * Creates and adds a shooting star element to the scene.
 */
function createShootingStar(): void {
  if (!memorialScene) return;

  const wrapper = document.createElement('div');
  wrapper.className = 'shooting-star-wrapper';

  const star = document.createElement('div');
  star.className = 'shooting-star';

  const startX = Math.random() * window.innerWidth;
  const startY = Math.random() * window.innerHeight * 0.4;
  const angle = Math.random() * 45 + 20;
  const duration = Math.random() * 2 + 1.5;

  wrapper.style.left = `${startX}px`;
  wrapper.style.top = `${startY}px`;
  wrapper.style.transform = `rotate(${angle}deg)`;
  
  star.style.animationDuration = `${duration}s`;

  star.addEventListener('animationend', () => {
    wrapper.remove();
  });

  wrapper.appendChild(star);
  memorialScene.appendChild(wrapper);
}

/**
 * Schedules the next shooting star to appear after a random delay.
 */
function scheduleNextShootingStar(): void {
  const delay = Math.random() * 15000 + 10000; // 10-25 seconds
  setTimeout(() => {
    createShootingStar();
    scheduleNextShootingStar();
  }, delay);
}


/**
 * Initializes the memorial scene.
 */
function initialize(): void {
  for (let i = 0; i < INITIAL_CANDLE_COUNT; i++) {
    const message = predefinedMessages[i % predefinedMessages.length];
    addCandleToScene(message, true);
  }
  
  checkSessionState();
  updateView();
  scheduleNextShootingStar();

  // --- Event Listeners ---
  if (messageForm) {
    messageForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      if (!messageInput.value.trim()) {
        showError("Vänligen skriv ett meddelande.");
        return;
      }
      
      hideError();
      lightCandleBtn.disabled = true;
      lightCandleBtn.textContent = 'Tänder ljus...';

      const message = messageInput.value.trim();
      const moderationResult = await checkMessageAppropriateness(message);

      if (moderationResult.isAppropriate) {
        const newCandle = addCandleToScene(message, false);
        updateView();

        requestAnimationFrame(() => {
            const candleRect = newCandle.getBoundingClientRect();
            const x = candleRect.left + candleRect.width / 2;
            const y = candleRect.top + candleRect.height / 2;
            showSparkleAt(x, y);
        });

        try {
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify({ hasLit: true, message: message }));
        } catch (err) {
            console.error('Could not save to localStorage', err);
        }

        if (thankYouMessage) {
            messageForm.style.display = 'none';
            thankYouMessage.style.display = 'block';
        }
      } else {
        showError(`Meddelandet kunde inte godkännas. Var snäll och försök formulera om det. (${moderationResult.reason})`);
        lightCandleBtn.disabled = false;
        lightCandleBtn.textContent = 'Tänd ett ljus';
      }
    });
  }

  if(candleContainer) {
    candleContainer.addEventListener('click', (e) => {
        const target = e.target as HTMLElement;
        if (target.classList.contains('candle') && target.dataset.message) {
            showMessage(target);
        }
    });
  }

  if(closeMessageBtn) {
    closeMessageBtn.addEventListener('click', hideMessage);
  }

  document.addEventListener('click', (e) => {
    if (messageDisplay?.classList.contains('visible') && !messageDisplay.contains(e.target as Node) && !(e.target as HTMLElement).classList.contains('candle')) {
        hideMessage();
    }
  });
}

// --- Start the application ---
initialize();
